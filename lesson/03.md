# 3. Параллельная сборка.

Суть параллельной сборки заключается в том, что одновременно вызываются несколько компиляторов для разных файлов. Смысл такого подхода заключается в многопроцессорности. Компилятор в настоящее время использует только один процессор. И если каждый следующий файл начинать компилировать только после завершения компиляции предыдущего файла, то оставшиеся процессоры будут простаивать.

### lesson03.1

Собственно для тестирования нам требуется несколько файлов с исходным кодом.

Вынесем класс RootFolder в отдельные файлы [src/root-folder.hpp](/../lesson03.1/src/root-folder.hpp) и [src/root-folder.cpp](/../lesson03.1/src/root-folder.cpp).

Также у нас появляется файл [src/stdlibs.hpp](/../lesson03.1/src/stdlibs.hpp) с общими заголовками.

Из [src/main.cpp lesson03.1](/../lesson03.1/src/main.cpp) таким образом часть кода удалена, [посмотреть отличия](/../../compare/c030..c031).

### lesson03.2

При праллельной работе нескольких компиляторов их вывод будет перемешан. В результате чего невозможно понять, к какому файлу относится сообщение. Чтобы избежать этого, во время работы компилятора сохраним его вывод в памяти, а после завершения выведем пользователю. При этом вывод жёстко последовательный. Для получения вывода компилятора используем асинхронную модель средствами [boost::asio](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio.html).

Для хранения вывода компилятора создадим класс Buffer в файле [src/buffer.hpp](/../lesson03.2/src/buffer.hpp).

### lesson03f
